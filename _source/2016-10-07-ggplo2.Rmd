---
layout: post
title: "Programming with ggplot2"
permalink: /anonblogentry/
date: 2016-10-7 20:25
description: "How you can make ggplot really flexible and apply to a lot 
  of different data types."
tags: jekyll ggplot2
---
Look at the pre-processed data below.
```{r, message=FALSE}
library("tidyverse")
source("multiplot.R") # http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
```

```{r}
dta <- select(diamonds, price, cut, carat, color)
```

Now, imagine you want a quick summary for each variable. Unfortunately, the 
variabels are not all of the same class.
For the factors, you could do a bar chart, for the integers, you might wan to
use a histogram. You could do the following for cut and color.
```{r}
p1 <- ggplot(dta, aes(cut)) + geom_bar()
p2 <- ggplot(dta, aes(color)) + geom_bar()
```

Similarly, you can do for price and carat
```{r}
p3 <- ggplot(dta, aes(price)) + geom_density(color = "black", fill = "black")
p4 <- ggplot(dta, aes(carat)) + geom_density(color = "black", fill = "black")

multiplot(p1, p2, p3, p4, cols = 2)
```

Now, you can note two things

* you have a lot of code duplication
* you need to futher customize the second graph with a transformation to
  make the visualization more intersting.
  
To address the first problem, part of the answer is creating a function that
behaves differently depending on whether the input is factorial or numeric.
```{r, eval=F}
# a function that returns geom_hist if the input is numberic, 
# geom_bar otherwise
geom_hist_or_bar <- function() {
  if(current_class() %in% c("integer", "numeric")) {
  geom_density(color = "black", fill = "black")
  } else {
  geom_bar()
  }
}
```
`current_class` is a function that magically gets the class of the variable
that you used in `aes` of `ggplot`. 
Similarly, we can define a function `scale_x_adapt` that returns a transformed
scale if the input is numerical (using the `current_class` function again.)
Having defined that function, you could 
rewrite the above as follows.
```{r, eval = FALSE}
ggplot(dta, aes(color)) + geom_hist_or_bar()
ggplot(dta, aes(cut))   + geom_hist_or_bar()
ggplot(dta, aes(price))  + geom_hist_or_bar()
ggplot(dta, aes(carat))   + geom_hist_or_bar()
```
This is a slight improvement to the first solution, because you always call the
same functions for all plots. Hence, we can kind of use an `apply` approach to 
reduce the redundancy of this problem. You might think of the following
```{r, eval=FALSE}
lapply(dta, function(g) ggplot(dta, aes(g)) + geom_hist_or_bar)
```
Unfortunately, this does not quite work, because `x` will be the actual 
values from each column, but in `aes`, you need the name of the column, not the 
actual value. Since there is no way to get from the values to the names, but 
if we have the names, we can get the values, the trick is to loop over the names
of the data frame. In this case, we need to wrap the names in `as.list`, because
names will be a vector, but `lapply` wants to iterate over a list.
```{r, eval=FALSE}
lapply(as.list(names(dta)), function(x) ggplot(dta, aes(x)) + geom_hist_or_bar)
```
However, we are not quite there yet. Due to non-standard evaluation, we need to 
further change two things.

* use `_aes` instead of `_aes` so `x` is not acutally x, but points to something
  else.
* use `as.name(x)` instead of `x` because `x` is just the name of an object (i.e. 
  "cut" for the first iteration), not the object itself. 
  
Now, we are done.
```{r, eval=FALSE}
lapply(as.list(names(dta)), function(g) { # seems as it needs to be a list!
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})

```
The only explanation I still owe you is how the function `current_class()` works.
It only works because it is called from within `lapply`. 
Hence, the parent frame of `current_class` is `lapply`. For a given iteration, 
the value of g is available in the environment of `lapply`. `currrent_class` 
simply needs to go *up the tree* until it reaches the environment of `lapply` 
and get the value of g and figure out it's class. That is done as follows.
```{r}
current_class <- function() {
  # returns the first class of the current iteration*
  class(dta[[get("g", parent.frame(n = 2))]])[1]
}
# * first element since object can have multiple classes
```

Finally, we can get it running
```{r}
current_class <- function() {
  # returns the first class of the current iteration*
  class(dta[[get("g", parent.frame(n = 2))]])[1]
}
# * first element since object can have multiple classes

geom_hist_or_bar <- function() {
  color <- "gray"
  if(current_class() %in% c("integer", "numeric")) {
  geom_density(color = color, fill = color)
  } else {
  geom_bar(color = color, fill = color)
  }
}

scale_x_adapt <- function() {
  if(current_class() %in% c("integer", "numeric")) {
    scale_x_continuous(trans = "log") 
  } else {
    scale_x_discrete()
  }
  
}

all_plots <- lapply(as.list(names(dta)), function(g) { # seems as it needs to be a list!
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})

do.call("multiplot", list(plotlist = all_plots, cols = 2)) # use plotlist not ... as input

```

