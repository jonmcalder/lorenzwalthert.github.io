---
title: "Programming with ggplot2 - Part II"
description: How one can take advantage of integrating ggplot with core 
  elements of the R language to create more flexible and adaptive plots while 
  reduce redundancy. In particular, this post discusses how we can apply a set
  of functions over all columns of a dataframe to produce plots for each column
  that depend on the class of the current column. 
date: "2016-10-11 19:05"
permalink: /proggplotII/
tags: ggplot2
layout: post
comments: true
---
## Introduction
<br/>

This blog post is the follow-up on part one on programming with ggplot2. In this
post, we will adress the problem of axis labels. Recall from part one that we ended 
up with the following code to produce four graphs for two different data types.

{% highlight r %}
##  ............................................................................
##  get set up
library(tidyverse)
source("multiplot.R") # http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
dta <- select(diamonds, price, cut, carat, color)


##  ............................................................................
##  define helper functions
current_class <- function() {
  # returns the first class of the current iteration*
  class(dta[[get("g", parent.frame(n = 2))]])[1]
}
# * first element since object can have multiple classes

geom_hist_or_bar <- function() {
  color <- "gray"
  if (current_class() %in% c("integer", "numeric")) {
  geom_density(color = color, fill = color)
  } else if(current_class() %in% c("factor", "ordered")){
  geom_bar(color = color, fill = color)
  }
}

scale_x_adapt <- function() {
  if (current_class() %in% c("integer", "numeric")) {
    scale_x_continuous(trans = "log") 
  } else if(current_class() %in% c("factor", "ordered")){
    scale_x_discrete()
  }
  
}

##  ............................................................................
##  create all plots
all_plots <- lapply(as.list(names(dta)), function(g) {
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})


##  ............................................................................
##  compose plots
# use plotlist not ... as input
do.call("multiplot", list(plotlist = all_plots, cols = 2)) 
{% endhighlight %}

![plot of chunk unnamed-chunk-1](/figure/source/2016-10-11-ggplot2II/unnamed-chunk-1-1.png)

We need to change the way the breaks are created within `scale_x_adapt`. To 
produce appropriate breaks, we need to know the maximum and the mimimum of the 
data we are dealing (that is, the column that `lapply` currently passes over) 
and then create a sequence between the minimum and the maximum.
Recall that we had a function `current_class` that did 
something similar to what we want. It got the class of the current data. Hence,
we can expand this function to get any property from our current data (and 
give the function a more general name).

{% highlight r %}
current_property <- function(f) {
  # returns a property of the current iteration object
  f(dta[[get("g", parent.frame(n = 2))]])[1]
}
{% endhighlight %}
Note the new argument f, which allows us get a wider range of properties of
the current data, not just the class, as `current_class` did. 
In our case, we are interested in the minimal and maximal 
value of the current data batch. Hence, we need to replace `current_class()` with
`current_property(class)` everywhere.
Next, we calculate the new break points within `scale_x_adapt`. This is a bit 
tricky. We end up with the following code to do that:

{% highlight r %}
calc_breaks <- round(
  exp(
    seq(log(current_property(min)), log(current_property(max)), length.out = 5)), 
  -log10(current_property(max) - current_property(min)) + 2)
{% endhighlight %}
Let me break this uggly looking two lines into pieces. 
- The basic idea is  to create a sequence of breaks between the minimal and the 
  maximal value of the current data batch using `seq`.
- Since our plot is going to be on a logarithmic x-axis, we need to create a linear sequence 
  between `log(start)` and `log(end)` and transform it with `exp` so we end up
  with breaks that looks linear on the logaritmic scale. 
- We want to round the values depending on their absolute value. For example, 
  the values for carat (which are in the range of 0.2 to 5) should be rounded to
  maybe one decimal point, whereas the values of price (ranging up to 18'000) 
  should be rounded to thousands or tenthousands. 
  So note that log10(10) is one, log10(100) = 2 and log10(0.1) = -1 ect, which 
  is exactly what we need. We choose the rounding such 
  that the range of values matters, but we want see two more decimal numbers 
  than the range has, so we add 2 there. 

Finally, we can put it all together:

{% highlight r %}
##  ............................................................................
##  define helper-funtions
current_property <- function(f, n = 2) {
  # returns a property of the current iteration object
  f(dta[[get("g", parent.frame(n = n))]])[1]
}

geom_hist_or_bar <- function() {
  color <- "gray"
  if (current_property(class) %in% c("integer", "numeric")) {
  geom_density(color = color, fill = color)
  } else {
  geom_bar(color = color, fill = color)
  }
}

scale_x_adapt <- function() {
  if (current_property(class) %in% c("integer", "numeric")) {
    
    # calculate the breaks
    calc_breaks <- round(exp(seq(log(current_property(min)), log(current_property(max)), 
        length.out = 5)), -log10(current_property(max))+2)
    
    scale_x_continuous(trans = "log", 
      breaks = calc_breaks)
  } else {
    scale_x_discrete()
  }
  
}

##  ............................................................................
##  generate plots
all_plots <- lapply(as.list(names(dta)), function(g) { 
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})


##  ............................................................................
##  compose the plots 
# use plotlist not ... as input
do.call("multiplot", list(plotlist = all_plots, cols = 2)) 
{% endhighlight %}

![plot of chunk unnamed-chunk-4](/figure/source/2016-10-11-ggplot2II/unnamed-chunk-4-1.png)

