---
title: "Programming with ggplot2 - Part I"
description: How one can take advantage of integrating ggplot with core 
  elements of the R language to create more flexible and adaptive plots while 
  reduce redundancy. In particular, this post discusses how we can apply a set
  of functions over all columns of a dataframe to produce plots for each column
  that depend on the class of the current column. 
date: "2016-10-7 20:25"
permalink: /proggplotI/
tags: ggplot2
layout: post
comments: true
---

## Introduction
<br/>
This series discusses how we can apply a set of functions over all 
columns of a dataframe to produce plots for each column that depend on the 
class of the current column. 
To this end, we integrate the following concepts / functions:

* the `ggplot2` package
* `lapply`
* anonymous functions
* non-standard evaluation
* lexical scoping

The reader should be familiar with these concepts, otherwise, Hadley Wickham's
[Advanced R](http://adv-r.had.co.nz) might be a good starting point to read 
up on these topics (all except the first one).

The approach discussed here generalizes to
other situations in which one want to customize plots based on the 
characteristics of input data.

## Problem
<br/>
For this blog post, we are going to use a subset of the diamonds dataset.

{% highlight r %}
library("tidyverse")
source("multiplot.R") # http://www.cookbook-r.com/Graphs/Multiple_graphs_on_one_page_(ggplot2)/
{% endhighlight %}


{% highlight r %}
dta <- select(diamonds, price, cut, carat, color)
head(dta)
{% endhighlight %}



{% highlight text %}
## # A tibble: 6 Ã— 4
##   price       cut carat color
##   <int>     <ord> <dbl> <ord>
## 1   326     Ideal  0.23     E
## 2   326   Premium  0.21     E
## 3   327      Good  0.23     E
## 4   334   Premium  0.29     I
## 5   335      Good  0.31     J
## 6   336 Very Good  0.24     J
{% endhighlight %}

Now, imagine you want a quick visual summary for each variable. Unfortunately, 
the variabels are not all of the same class.
For the factors, you could do a bar chart, for the integers, you might wan to
use a density plot. You could do the following for cut and color. Let's have
a look at a first approach.

{% highlight r %}
p1 <- ggplot(dta, aes(cut)) + geom_bar()
p2 <- ggplot(dta, aes(color)) + geom_bar()
{% endhighlight %}

Similarly, you can do for price and carat

{% highlight r %}
p3 <- ggplot(dta, aes(price)) + geom_density()
p4 <- ggplot(dta, aes(carat)) + geom_density()

multiplot(p1, p2, p3, p4, cols = 2)
{% endhighlight %}

![plot of chunk unnamed-chunk-4](/figure/source/2016-10-07-ggplot2I/unnamed-chunk-4-1.png)
<br/>

Now, you can note two things

* you have a lot of code duplication.
* you might want to futher customize the density graphs with a transformation to
  make the visualization more intersting.
  
  
## A solution
<br/>
To address the first problem, we can create a function that
behaves differently depending on whether the input is factorial or numeric.

{% highlight r %}
# a function that returns geom_hist if the input is numberic, 
# geom_bar otherwise
geom_hist_or_bar <- function() {
  if(current_class() %in% c("integer", "numeric")) {
  geom_density(color = "black", fill = "black")
  } else {
  geom_bar()
  }
}
{% endhighlight %}
`current_class` is a function that magically gets the class of the variable
that you used in `aes` of `ggplot`. 
Similarly, we can define a function `scale_x_adapt` that returns a transformed
scale if the input is numerical (using the `current_class` function again.)
Having defined that function, you could 
rewrite the above as follows:

{% highlight r %}
ggplot(dta, aes(color)) + geom_hist_or_bar()
ggplot(dta, aes(cut))   + geom_hist_or_bar()
ggplot(dta, aes(price)) + geom_hist_or_bar()
ggplot(dta, aes(carat)) + geom_hist_or_bar()
{% endhighlight %}
This is a slight improvement to the first solution, because you always call the
same functions for all plots. Hence, we can kind of use an `apply` approach to 
reduce the redundancy of this problem. You might think of the following:

{% highlight r %}
lapply(dta, function(g) ggplot(dta, aes(g)) + geom_hist_or_bar)
{% endhighlight %}
Unfortunately, this does not quite work, because for each iteration in 
`lapply`, `g` will be the actual 
values from each column, but in `aes`, you need the name of the column, not the 
actual value. Since there is no way to get from the values to the names, but 
if we have the names, we can get the values, the trick is to loop over the names
of the data frame. In this case, we need to wrap the names in `as.list`, because
names will be a vector, but `lapply` wants to iterate over a list.

{% highlight r %}
lapply(as.list(names(dta)), function(g) ggplot(dta, aes(g)) + geom_hist_or_bar)
{% endhighlight %}
However, we are not quite there yet. Due to non-standard evaluation, we need to 
further change two things:

* use `_aes` instead of `_aes` so `g` is not acutally g, but points to something
  else.
* use `as.name(g)` instead of `g` because `g` is just the name of an object (i.e. 
  "cut" for the first iteration), not the object itself. 
  
Now, we are done.

{% highlight r %}
lapply(as.list(names(dta)), function(g) {
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})
{% endhighlight %}
The only explanation I still owe you is how the function `current_class()` works.
It only works because it is called from within `lapply`. 
Hence, the parent frame of `current_class` is `lapply`. For a given iteration, 
the value of g is available in the environment of `lapply`. `currrent_class` 
simply needs to go *up the tree* until it reaches the environment of `lapply` 
and get the value of g and figure out it's class. That is done as follows.

{% highlight r %}
##  ............................................................................
##  define helper functions
current_class <- function() {
  # returns the first class of the current iteration*
  class(dta[[get("g", parent.frame(n = 2))]])[1]
}
# * first element since object can have multiple classes

geom_hist_or_bar <- function() {
  color <- "gray"
  if (current_class() %in% c("integer", "numeric")) {
  geom_density(color = color, fill = color)
  } else if(current_class() %in% c("factor", "ordered")){
  geom_bar(color = color, fill = color)
  }
}

scale_x_adapt <- function() {
  if (current_class() %in% c("integer", "numeric")) {
    scale_x_continuous(trans = "log") 
  } else if(current_class() %in% c("factor", "ordered")){
    scale_x_discrete()
  }
  
}

##  ............................................................................
##  create all plots
all_plots <- lapply(as.list(names(dta)), function(g) {
  ggplot(dta, aes_(as.name(g))) + 
    geom_hist_or_bar() +
    scale_x_adapt()
})


##  ............................................................................
##  compose plots
# use plotlist not ... as input
do.call("multiplot", list(plotlist = all_plots, cols = 2)) 
{% endhighlight %}

![plot of chunk unnamed-chunk-10](/figure/source/2016-10-07-ggplot2I/unnamed-chunk-10-1.png)

However, there is one thing bothering: the axis labels don't look nice. This
will be addressed in the second part of this series.

## Conclusion
<br/>
In this blog post, a few advanced consepts from the R toolbox were used in order
to create a set of functions that can be applied to numerical and factorial data
and creates appropriate plots. There is no need to call different functions for 
the different data types. This set of functions can be used in conjunction with `lapply` to
create summary plots, which would not be possible if different functions would 
have been used for the different data types.
We will continue this avenue with further customization in the second part of 
the series.
